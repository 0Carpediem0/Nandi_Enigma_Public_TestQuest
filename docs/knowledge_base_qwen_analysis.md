# Анализ: сможет ли Qwen работать с базой knowledge_base

## Текущая структура таблицы `knowledge_base`

| Колонка        | Тип           | Назначение |
|----------------|---------------|------------|
| id             | SERIAL        | Первичный ключ |
| title          | VARCHAR(500)  | Заголовок темы (вопрос/название) |
| content        | TEXT          | Полный текст ответа |
| short_answer   | TEXT          | Краткий ответ (до 500 символов) |
| tags           | TEXT[]        | **Шаблонные вопросы** — фразы, приводящие к этой теме |
| category       | VARCHAR(100)  | Категория |
| keywords       | TEXT[]        | Ключевые слова |
| usage_count    | INTEGER       | Счётчик использований |
| success_rate   | FLOAT         | Оценка полезности |
| is_active      | BOOLEAN       | Активна ли запись |
| created_at     | TIMESTAMP     | — |
| updated_at     | TIMESTAMP     | — |
| search_vector  | tsvector      | Полнотекстовый поиск по title + content (GIN-индекс) |

**Индексы:** GIN по `tags`, по `search_vector`, по `category`, по `is_active`, по `usage_count`.

---

## Вывод: **да, с такой базой Qwen сможет выдавать ответы клиентам**

Но только если добавить слой между БД и Qwen: **поиск по базе знаний** и **формирование контекста для модели**.

### Что уже есть и подходит под Qwen

1. **Данные для ответов**
   - `title` + `content` — то, что можно подставлять в промпт Qwen как контекст.
   - `short_answer` — готовый короткий ответ; можно использовать как черновик или как один из вариантов ответа.

2. **Поиск по запросу клиента**
   - `search_vector` — полнотекстовый поиск PostgreSQL по `title` и `content` (индекс GIN).
   - Можно по тексту вопроса клиента находить релевантные строки (через `plainto_tsquery` / `to_tsquery` и `ts_rank`).
   - `tags` хранят шаблонные вопросы — по ним тоже можно искать (совпадение по массиву или полнотекстовый поиск по `tags`), чтобы «подтягивать» нужную тему даже при других формулировках.

3. **Структура под RAG**
   - Типичная схема: запрос пользователя → поиск по БД → несколько записей (title + content) как контекст → Qwen генерирует ответ по контексту.
   - Текущих полей (title, content, short_answer, category, tags) для этого достаточно.

### Что мешает «из коробки»

1. **Нет API поиска по базе знаний**
   - В бэкенде нет функции вида «по вопросу клиента вернуть топ-N записей из `knowledge_base`».
   - Нужна реализация: запрос → SQL по `search_vector` (и при желании по `tags`) → возврат id, title, content, short_answer.

2. **Нет связки «поиск → Qwen»**
   - Нет эндпоинта/сервиса, который: принимает вопрос → ищет в `knowledge_base` → передаёт найденное в Qwen → возвращает ответ клиенту.
   - Это нужно реализовать поверх уже существующей таблицы.

3. **Полнотекстовый поиск на `simple`**
   - Сейчас: `to_tsvector('simple', ...)` — без морфологии и стемминга для русского.
   - «Сброс» и «сбросить» не будут считаться одним и тем же словом; качество поиска по русскому тексту можно улучшить (например, конфиг `russian` или другой парсер), но для первого варианта и `simple` достаточно.

4. **Нет векторного поиска (эмбеддинги)**
   - Колонки `embedding` нет — только лексический поиск (слова из запроса).
   - Семантический поиск («не включается» → «не запускается») потребовал бы эмбеддинги и pgvector; для старта можно обойтись текущим полнотекстовым поиском и шаблонными вопросами в `tags`.

---

## Рекомендации

1. **Добавить в backend функцию поиска по `knowledge_base`:**
   - Вход: текст вопроса клиента, опционально лимит (например, 5).
   - Выполнять поиск по `search_vector` (и при необходимости по `tags`).
   - Возвращать список записей: id, title, content, short_answer (и при необходимости category).

2. **Добавить слой «Qwen + база знаний»:**
   - Вход: вопрос клиента.
   - Вызвать поиск по БД → получить 1–5 релевантных записей.
   - Сформировать промпт для Qwen: системный промпт + контекст из этих записей (title + content) + вопрос клиента.
   - Ответ Qwen отдавать клиенту (и при желании сохранять в тикете как черновик ответа).

3. **Опционально позже:**
   - Подключить конфигурацию полнотекстового поиска для русского (`russian`), чтобы улучшить поиск по разным формам слов.
   - Если понадобится семантика — вернуть колонку `embedding` (pgvector) и заполнять её эмбеддингами от той же модели, что будет использоваться для поиска (или от отдельной модели эмбеддингов).

**Итог:** текущей структуры `knowledge_base` достаточно, чтобы Qwen выдавал ответы клиентам на основе базы знаний. Нужно реализовать поиск по этой таблице и интеграцию «поиск → контекст → Qwen → ответ».
